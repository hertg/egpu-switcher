package service

import (
	"bytes"
	"context"
	"fmt"
	"html/template"
	"os"
	"path/filepath"
	"sync"

	"github.com/coreos/go-systemd/v22/dbus"
	"github.com/hertg/egpu-switcher/internal/logger"
)

const sharePath = "/usr/share/egpu-switcher/egpu.service"
const servicePath = "/etc/systemd/system/egpu.service"
const serviceName = "egpu.service"

type Systemd struct {
	dbusConn *dbus.Conn
	once     sync.Once
}

func (s *Systemd) conn(ctx context.Context) *dbus.Conn {
	var err error
	s.once.Do(func() {
		s.dbusConn, err = dbus.NewSystemdConnectionContext(ctx)
		if err != nil {
			panic("unable to get dbus system connection to systemd")
		}
	})
	return s.dbusConn
}

func (s *Systemd) displayManagerName() (string, error) {
	dmServiceName, err := os.Readlink("/etc/systemd/system/display-manager.service")
	if err != nil {
		return "", err
	}
	return filepath.Base(dmServiceName), nil
}

func (s *Systemd) StopUnit(ctx context.Context, name string, verbose bool) error {
	conn := s.conn(ctx)
	_, err := conn.StopUnitContext(ctx, name, "replace", nil)
	return err
}

func (s *Systemd) StartUnit(ctx context.Context, name string, verbose bool) error {
	conn := s.conn(ctx)
	_, err := conn.StopUnitContext(ctx, name, "replace", nil)
	return err
}

func (s *Systemd) StopDisplayManager(ctx context.Context, verbose bool) error {
	name, err := s.displayManagerName()
	if err != nil {
		return err
	}
	return s.StopUnit(ctx, name, verbose)
}

func (s *Systemd) StartDisplayManager(ctx context.Context, verbose bool) error {
	name, err := s.displayManagerName()
	if err != nil {
		return err
	}
	return s.StartUnit(ctx, name, verbose)
}

func (s *Systemd) IsDisplayManagerStopped(ctx context.Context, verbose bool) (bool, error) {
	conn := s.conn(ctx)
	name, err := s.displayManagerName()
	if err != nil {
		return false, err
	}
	props, err := conn.GetUnitPropertiesContext(ctx, name)
	if err != nil {
		return false, err
	}
	return props["ActiveState"] == "inactive", nil
}

func (s *Systemd) CreateService(ctx context.Context, verbose bool) error {
	serviceTemplate := `# generated by egpu-switcher
[Unit]
Description=EGPU Service
Before=display-manager.service
After=bolt.service

[Service]
Type=oneshot
ExecStart=/usr/bin/egpu-switcher switch auto

[Install]
WantedBy=graphical.target
`

	buf := bytes.NewBuffer(nil)
	t := template.Must(template.New("service").Parse(serviceTemplate))
	err := t.Execute(buf, nil)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(filepath.Dir(sharePath), 0644); err != nil {
		return err
	}

	if err := os.WriteFile(sharePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("unable to generate systemd service file: %s", err)
	}

	if verbose {
		logger.Debug("generated systemd unit file at '%s'", sharePath)
	}

	systemd := s.conn(ctx)
	err = systemd.ReloadContext(ctx)
	if err != nil {
		return fmt.Errorf("unable to run systemd daemon-reload: %s", err)
	}
	_, _, err = systemd.EnableUnitFilesContext(ctx, []string{sharePath}, false, false)
	if err != nil {
		return fmt.Errorf("unable to enable %s: %s", serviceName, err)
	}

	if verbose {
		logger.Debug("enabled systemd unit '%s'", serviceName)
	}
	return nil
}

func (s *Systemd) TeardownService(ctx context.Context, verbose bool) error {
	conn := s.conn(ctx)

	prop, err := conn.GetUnitPropertiesContext(ctx, serviceName)
	if err != nil {
		return err
	}

	if prop["LoadState"] == "loaded" {
		if _, err := conn.StopUnitContext(ctx, serviceName, "replace", nil); err != nil {
			return fmt.Errorf("unable to stop systemd unit: %s", err)
		}
		if _, err := conn.DisableUnitFilesContext(ctx, []string{serviceName}, false); err != nil {
			return fmt.Errorf("unable to disable systemd unit: %s", err)
		}
	}

	if err := conn.ReloadContext(ctx); err != nil {
		return fmt.Errorf("unable to reload systemd daemon: %s", err)
	}

	// the old script ran a 'systemctl reset-failed' here, what for?

	if err := os.Remove(sharePath); err != nil {
		if !os.IsNotExist(err) {
			return fmt.Errorf("unable to remove %s: %s", sharePath, err)
		}
	} else {
		if verbose {
			logger.Debug("file '%s' was removed", sharePath)
		}
	}

	return nil
}
