#!/usr/bin/env bash

set -o errexit # exit script if a command fails
set -o nounset # exit when trying to use undeclared variables
#set -o xtrace # debug

# define some colors
declare red='\033[1;31m'
declare yellow='\033[1;33m'
declare green='\033[1;32m'
declare blue='\033[1;34m'
declare blank='\033[0m'

# define log level prefix
declare error="$red[error]$blank"
declare warn="$yellow[warn]$blank"
declare success="$green[success]$blank"
declare info="$blue[info]$blank"

# misc
declare datetime=$(date '+%Y%m%d%H%M%S')
declare number_regex='^[0-9]+$'

# constant variables for X-Server files
declare xdir=/etc/X11
declare xfile=$xdir/xorg.conf
declare xfile_egpu=$xdir/xorg.conf.egpu
declare xfile_internal=$xdir/xorg.conf.internal
declare xfile_backup=$xfile.backup

# constant variables for temp files
declare tmp_template=/usr/share/egpu-switcher/xorg.conf.template

# constant variables for systemd files
declare systemd_template=/usr/share/egpu-switcher/egpu.service
declare systemd_folder=/etc/systemd/system

# todo: this assumes that there is bash 4+ installed
declare -A gpus=()
declare gpu_connected=0

# helper method for printing error messages
function print_error() {
	echo -e "$error $1"
}

# helper method for printing info messages
function print_info() {
	echo -e "$info $1"
}

# helper method for printing warn messages
function print_warn() {
	echo -e "$warn $1"
}

# helper method for printin success messages
function print_success() {
	echo -e "$success $1"
}

# config
config_dir=~/.config/hertg
config_file=${config_dir}/egpu-switcher.conf
typeset -A config
config=(
	[internal_gpu]=""
	[internal_driver]=""
	[external_gpu]=""
	[external_driver]=""
)

# read from config file
if [ -f $config_file ]; then
	#print_info "Reading contents of your current configuration file at '${config_file}'"
	while read line
	do
		if echo $line | grep -F = &>/dev/null
		then
			varname=$(echo "$line" | cut -d '=' -f 1)
			config[$varname]=$(echo "$line" | cut -d '=' -f 2-)
		fi
	done < $config_file
fi

# check if the script is run as root
if [[ $EUID -ne 0 ]]; then 
  	print_error "You need to run the script with root privileges"
  	exit
fi

# check if an argument was passed
if [ -z ${1+x} ]; then
	print_error "No argument passed."
	exit
fi

# read the connected GPUs and put them into the "gpus" associative array
function read_gpus() {

	# empty the gpus array
	gpus=()

	declare lines=$(lspci | grep -i -E "^[^\s]+\s+.*(vga|3d)")
	while read -r line ; do
		declare name=$(echo $line | grep -o -e "[^:]*$")
		declare bus=$(echo $line | grep -o -e "^[^ ]*")

		# The bus IDs in hex
		declare bus1h=${bus:0:2}
		declare bus2h=${bus:3:2}
		declare bus3h=${bus:6:1}

		# The bus IDs in dec
		declare bus1d=$((16#$bus1h))
		declare bus2d=$((16#$bus2h))
		declare bus3d=$((16#$bus3h))

		# Remove the whitespace at the beginning of the name
		# And concatenate bus IDs
		bus="${bus1d}:${bus2d}:${bus3d}"
		name=${name:1}

		# Put the result into the gpus array
		gpus+=( [$bus]=$name )
	done <<< $lines
	return
}

# returns 1 if egpu is connected, 0 if not
function is_egpu_connected() {

	# read pci id from xorg.conf.egpu
	declare egpu_pci_id=$(cat $xfile_egpu | grep -Ei "BusID" | grep -oEi '[0-9]+\:[0-9]+\:[0-9]+')

	# giving your egpu some time to actually connect
	sleep 5s

	# create an array by splitting the BUS-ID on ':'
	declare busArray=(${egpu_pci_id//:/ })
	declare bus1d=${busArray[0]}
	declare bus2d=${busArray[1]}
	declare bus3d=${busArray[2]}

	# convert dec to hex
	declare bus1h=$(printf "%02x" $bus1d)
	declare bus2h=$(printf "%02x" $bus2d)
	declare bus3h=$(printf "%01x" $bus3d)

	if [ $(lspci | grep -iEc "$bus1h:$bus2h.$bus3h") -eq 1 ]; then
		print_info "EGPU is ${green}connected${blank}."
		gpu_connected=1
		#return 1
	else
		print_info "EGPU is ${red}disconnected${blank}."
		gpu_connected=0
	fi
}

# get the matching driver according to the gpu name
function get_driver() {
	if [ -z ${1+x} ]; then
		print_error "No argument was passed to get_driver(), this is probably a bug and not your fault."
		exit
	fi

	if [ $(echo "$1" | grep -Eic "nvidia") -gt 0 ]; then
		echo "nvidia"
		return
	fi

	if [ $(echo "$1" | grep -Eic "intel") -gt 0 ]; then
		echo "intel"
		return
	fi

	if [ $(echo "$1" | grep -Eic "amd") -gt 0 ]; then
		echo "amdgpu"
		return
	fi
}

# prompts the user to define their external/internal GPUs
# and saves it into the config file
function configure() {

	# reset current config
	config[internal_gpu]=""
	config[internal_driver]=""
	config[external_gpu]=""
	config[external_driver]=""

	# read currently attached GPUs
	read_gpus

	# save the number of lines to a variable
	declare num_of_gpus=${#gpus[@]}

	# additional check
	if [ $num_of_gpus -lt "2" ]; then
		print_warn "Only ${num_of_gpus} GPUs found, there need to be at least 2. Make sure to connect your EGPU for the setup."
		exit
	fi

	# print the GPUs found
	echo ""
	echo -e "Found $num_of_gpus possible GPUs..."
	echo ""

	declare mapping=()
	declare i=0
	for key in ${!gpus[@]}; do
		i=$((i+1))
		mapping+=([${i}]=${key})
		echo "  $i: ${gpus[${key}]} (${key})"
	done

	echo ""

	printf "Would you like to define a specific$green INTERNAL$blank GPU? [y/N]: "
	read specify_internal
	if [[ $specify_internal == "y" ]]; then
		# prompt to choose the internal gpu from the list
		printf "Choose your preferred$green INTERNAL$blank GPU [1-$num_of_gpus]: "
		read internal
		declare full_internal=${gpus[${mapping[$internal]}]}
		declare pci_internal=${mapping[$internal]}

		if ! [[ $internal =~ $number_regex ]] || [ -z "$pci_internal" ]; then
			print_error "Your input is invalid. Exiting setup..."
			exit
		fi	

		config[internal_gpu]=${pci_internal}
		config[internal_driver]=$(get_driver "$full_internal")

		if [ -z ${config[internal_driver]} ]; then
			print_info "Could not parse manufacturer from \"$full_internal\"."
			printf "Please manually enter the driver to be used: "
			read driver
			config[internal_driver]=${driver}
		fi
	fi

	# prompt to choose the external gpu from the list
	printf "Choose your preferred$green EXTERNAL$blank GPU [1-$num_of_gpus]: "
	read external
	declare full_external=${gpus[${mapping[$external]}]}
	declare pci_external=${mapping[$external]}

	if ! [[ $external =~ $number_regex ]] || [ -z "$pci_external" ]; then
		print_error "Your input is invalid. Exiting setup..."
		exit
	fi

	config[external_gpu]=${pci_external}
	config[external_driver]=$(get_driver "$full_external")

	if [ -z "${config[external_driver]}" ]; then
		print_info "Could not parse manufacturer from \"$full_external\"."
		printf "Please manually enter the driver to be used: "
		read driver
		config[external_driver]=${driver}
	fi

	echo ""

	# create config directory if it doesnt exist
	mkdir -p $config_dir

	# empty current config file
	true > $config_file

	# write new configurations to config file
	for key in ${!config[@]}; do
		echo "${key}=${config[${key}]}" >> $config_file
	done

	print_info "Saved new configuration to ${config_file}"
}

setup() {

	# check if the template/script files can be found
	if [ ! -f $tmp_template ]; then
		print_error "The file $tmp_template wasn't found."
		exit
	fi

	if [ -z ${config[external_gpu]} ]; then
		print_error "It seems like you haven't configured egpu-switcher yet. Please run 'egpu-switcher config' first."
		exit
	fi

	# create the internal xorg config file
	if [ ! -z ${config[internal_gpu]} ]; then
		cp $tmp_template $xfile_internal
		sed -i -e 's/\$BUS/'${config[internal_gpu]}'/g' -e 's/\$DRIVER/'${config[internal_driver]}'/g' -e 's/\$ID/Device0/g' $xfile_internal
	else 
		true > $xfile_internal
	fi

	# create the external xorg config file
	cp $tmp_template $xfile_egpu
	sed -i -e 's/\$BUS/'${config[external_gpu]}'/g' -e 's/\$DRIVER/'${config[external_driver]}'/g' -e 's/\$ID/Device0/g' $xfile_egpu

	# Executing the switch command to create the xorg.conf file
	if [ -z ${1+x} ]; then
		switch auto
	else
		switch auto $1
	fi

	# setup startup script
	cp $systemd_template $systemd_folder
	systemctl daemon-reload
	systemctl enable egpu.service

	print_success "Done... Setup finished"
}

switch() {
	
	# Check if the xorg.conf files for internal and egpu exist
	if ! [ -f $xfile_egpu ] || ! [ -f $xfile_internal ]; then
		print_error "The xorg.conf files for egpu and internal do not exist. Run the setup first."
		return
	fi

	# Check if there is a xorg.conf file, and back it up
	if [ -f $xfile ] && ! [ -L $xfile ]; then
		print_warn "The $xfile file already exists. Saving a backup to $xfile_backup.$datetime"
		cp "$xfile" "$xfile_backup.$datetime"
	fi

	# if no parameter was passed to the method
	if [ ${1} = "auto" ]; then

		print_info "Automatically detecting if egpu is connected... "
		is_egpu_connected
		if [ ${gpu_connected} = 1 ] ; then
			set -- "egpu"
		else
			set -- "internal"
		fi
	fi

	if [ ${1} = "egpu" ] && [ $(grep -ce "nvidia" $xfile_egpu) -eq 0 ]; then
		declare egpu_pci_id=$(cat $xfile_egpu | grep -Ei "BusID" | grep -oEi '[0-9]+\:[0-9]+\:[0-9]+')
		# create an array by splitting the BUS-ID on ':'
		declare busArray=(${egpu_pci_id//:/ })
		declare bus1d=${busArray[0]}
		declare bus2d=${busArray[1]}
		declare bus3d=${busArray[2]}

		# convert dec to hex
		declare bus1h=$(printf "%02x" $bus1d)
		declare bus2h=$(printf "%02x" $bus2d)
		declare bus3h=$(printf "%01x" $bus3d)
		
		declare hex_id=$(echo $bus1h:$bus2h.$bus3h)
		declare disp_path=/sys/bus/pci/devices/[0-9a-f:]*${hex_id}/drm/card[0-9]*/card[0-9]*-*/status
		declare disp_num=0
		declare disp_disconnect=0
		for disp in ${disp_path}; do
			if [ -e $disp ]; then
				disp_num=$(expr $disp_num + 1)
				disp_disconnect=$(expr $disp_disconnect + $(cat $disp | grep -ce ^disconnected$))
			fi
		done
		if [ $disp_disconnect -eq $disp_num ] && [ $disp_num -gt 0 ]; then
			print_warn "No eGPU attached display detected with open source drivers. (Of ${disp_num} eGPU outputs detected) Internal mode and setting DRI_PRIME variable are recommended for this configuration."
			if [ ! -z ${2+x} ]; then
				if [[ ${2} = "override" ]]; then
					print_warn "-> Overridden: Setting eGPU mode"
					set -- "egpu"
				else 
					print_error "Unknown argument '${2}' passed to 'switch ${1}' method. Possible option: override"
				fi
			else
				print_warn "Run 'egpu-switcher switch egpu override' to force loading eGPU mode"
				print_warn "-> Not setting eGPU mode."
				set -- "internal"
			fi
		fi
	fi

	if [ ${1} = "egpu" ]; then
		print_info "Create symlink ${green}${xfile}${blank} -> ${xfile_egpu}"
		ln -sf ${xfile_egpu} ${xfile}
		return
	fi

	if [ $1 = "internal" ]; then
		print_info "Create symlink ${green}${xfile}${blank} -> ${xfile_internal}"
		ln -sf ${xfile_internal} ${xfile}
		return
	fi

	print_error "The argument '${1}' that was passed to the switch() method is not valid."
}

cleanup() {
	print_info "Starting cleanup process"
	rm -rf ${xfile_egpu}
	rm -rf ${xfile_internal}

	# delete the xorg.conf file, if it is a symlink and restore the last backup
	if [ -L ${xfile} ]; then
		rm -rf ${xfile}
		local lastbackup=$(ls -t ${xfile_backup}.* | head -1)
		if [ -f ${lastbackup} ]; then
			print_info "Restoring latest backup ${green}${lastbackup}"
			mv ${lastbackup} ${xfile}
		fi
	fi

	systemctl stop egpu.service
	systemctl disable egpu.service
	rm ${systemd_folder}/egpu.service
	systemctl daemon-reload
	systemctl reset-failed

	print_success "Done... Finished cleanup"
}

if [ $1 = "setup" ]; then
	if [ -z ${2+x} ]; then
		setup
	else
		setup ${2}
	fi
elif [ $1 = "config" ]; then
	configure
elif [ $1 = "switch" ]; then
	if [ -z ${2+x} ]; then
		print_error "No argument passed to the switch method. Possible options: auto, egpu, internal"
	else
		if [ -z ${3+x} ]; then
			switch ${2}
		else
			switch ${2} ${3}
		fi		
	fi
	
elif [ $1 = "cleanup" ]; then
	cleanup
else
	print_error "Unknown argument '$1'.\navailable commands: setup, switch, cleanup"
fi

# systemctl restart display-manager.service
